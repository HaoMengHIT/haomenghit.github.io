<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Meng Hao&#39;s Homepage">
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        论文阅读：Energy-Dfficient Application Resource Scheduling Using Machine Learning Classifiers (ICPP18) - Meng Hao&#39;s Homepage
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> Ever tried. Ever failed. No matter. Try again. Fail again. Fail better. </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>Meng Hao</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>HOME</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>TAGS</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>ARCHIVES</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>ABOUT</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>SEARCH</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#研究背景"><span class="toc-text">¶研究背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何最大化能源效率"><span class="toc-text">¶如何最大化能源效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习能源效率"><span class="toc-text">¶学习能源效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统设置的分类"><span class="toc-text">¶系统设置的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#训练数据"><span class="toc-text">¶训练数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能计数器"><span class="toc-text">¶性能计数器</span></a></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">search</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> Ever tried. Ever failed. No matter. Try again. Fail again. Fail better. </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        论文阅读：Energy-Dfficient Application Resource Scheduling Using Machine Learning Classifiers (ICPP18)
    </div>

    <div class="post-meta">
        <span class="attr">Post：<span>2019-08-02 20:01:05</span></span>
        
        <span class="attr">Tags：/
        
        <a class="tag" href="/tags/#Papers" title="Papers">Papers</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#Energy Modeling" title="Energy Modeling">Energy Modeling</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">Visit：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h2 id="研究背景"><a class="header-anchor" href="#研究背景">¶</a>研究背景</h2>
<p>在未来的百亿亿次系统中，能源和电力消耗将是首要的制约因素。例如，这些系统预计有严格的运行预算，如20MW。此外，E级操作系统需要有效地降低每一次科学计算的成本。目前已经存在大量研究工作，通过直接优化科学计算时间开销来最大化HPC的性能。但是最近的研究（理论和实践）证明，为应用程序分配最大的资源并没有比智能地根据特定应用程序的需求调整资源使用策略更加节能。因此，一些研究在保证应用程序性能的同时降低能耗，来进一步减少科学计算的开销。然而，目前很少有工作来积极地减少系统能耗。即使运行时间增加，也要最大限度地减少应用程序的能耗，可以大大降低科学洞察力的成本（以焦耳为单位），并在过度配置的功耗受限系统（例如未来E级计算机）中增加应用的吞吐量，允许更多应用程序同时在集群上执行。</p>
<p>由于亿亿次级计算节点的复杂性和应用程序的动态特性，最大限度地减少E级系统的能耗，其资源需求在执行期间会有所不同。在节点内，可以调整许多不同的资源，这些资源会影响计算效率，包括动态电压和频率调整（DVFS），多插槽和核心分配以及HyperThreads的使用。这些资源的最节能配置因不同的应用程序而异，甚至在单个应用程序中也会因多个阶段的过渡而变化。</p>
<p>本文提出了再运行时动态监控应用程序和系统的方法，利用机器学习分类来预测应用程序执行时最节能的资源设置。该方法有两个不同的优点。首先，它可以应用于新的应用程序而无需修改分类器或应用程序，因为它不需要应用程序级别的插桩或挂钩。其次，分类开销低，使其适合在计算节点上原位运行。本文首先评估了15种不同的分类技术，并在四插槽x86计算节点上利用21个常用HPC基准测试和协同设计应用程序测试了他们在正确获取的节能配置的能力。实验发现，由于基础系统的复杂性使得许多分类方法不适用于预测节能配置的问题，但少数方法很有希望。然后，本文选择原有的15个分类技术中的5个，并评估它们动态管理四个高性能基因组装配应用程序的能力。这些代表了一些计算密集度最高的生物信息学应用程序，最常用的应用程序仅在单个共享内存节点上运行。因此，有一些HPC系统，如NERSC-Genepool [36]，主要用于同时执行许多单节点应用，如基因组装配和比较分析。</p>
<p>本文的评估提供以下见解。首先，选择一个能够处理观察到的运行时行为与能量系统设置的复杂非线性映射的分类器非常重要。与维持最高性能所需的策略相比，较差的分类可以导致能量消耗的非平凡增加，例如，在我们探索的一个案例中，增加22％。然而，鉴于一个非常强大的分类，所提议的方法平均减少20％的能量消耗 - 只比离线Oracle高出5.4％的能耗。我们计算将此行为扩展到过度配置的功率受限群集可以将总吞吐量提高24％。所有这些结果都是在没有应用程序的先验知识且没有应用程序级别的修改的情况下实现的。我们得出结论，通过部署机器学习分类器来动态调整资源使用情况，可以显着提高每焦耳的科学洞察力（scientific insight）。</p>
<p>综上所述，本文的贡献如下：</p>
<p>（1）提出优化能源效率而不是运行时间，以降低科学计算的成本。<br>
（2）建立了15种不同的机器学习分类技术评估的问题复杂性，只有一些适用于优化能源效率。<br>
（3）通过在运行时准确预测能量系统设置，证明有足够强大的分类器可以大大降低能耗。</p>
<h2 id="如何最大化能源效率"><a class="header-anchor" href="#如何最大化能源效率">¶</a>如何最大化能源效率</h2>
<p>集群能效可简单地定义为<strong><em>每焦耳能量完成的应用比率</em></strong>。如果每个应用程序执行代表某些科学洞察力单元，则该指标表示在运营成本（能源消耗）方面的科学洞察力的成本。因此，通过最小化应用能耗，最大化能效直接降低了科学洞察力的成本。然而，减少能量（Energy）消耗比简单地减少电功率（Power）更困难，因为<strong><em>能量是时间和功率的乘积</em></strong>，并且很难在不牺牲对方的情况下改善能量。例如，提高处理器速度通常会缩短应用程序运行时间，但必要的功率增加会导致能耗增加。简而言之，最大化能源效率并不意味着尽可能少地使用电力 - 这需要在执行时间和功耗之间进行最佳折中。</p>
<p>最近的能量感知方法在保持应用性能的同时降低了能量。由于这些方法不以减少应用程序的速度为代价，因此它们通过降低功率来严格降低能耗。虽然通过简单地消除应用程序运行时的约束来最小化能耗是很诱人的，但是如果不考虑低功率资源设置对执行时间的影响可能导致更差的能量消耗。</p>
<p>HPC集群中的典型资源管理方法主要是尝试优化应用程序完成时间，仅考虑功率消耗以达到不违反总集群功率约束的程度，并完全忽略能耗。虽然有各种技术可以将作业分配给节点，但通常可以通过尽可能快地运行各个计算节点来实现最小化其运行时间 - 这种方法我们称之为Race。使用Race方法使节点上的资源调度变得容易，但它不像能够理解系统配置如何在每个应用程序基础上最性能和功率进行折中的更智能的方法那样节能。原因是尽可能快地投入工作可以最大限度地缩短执行时间，但功率的增加使节省的时间相形见绌，从而导致高能耗。</p>
<p>除了降低成本之外，最大化能效还将提高功率受限环境中的整体系统吞吐量。在过度配置（Over-provisioned）的集群中，如果节点在Race设置中运行，硬件可以消耗比基础设施实际提供给系统更多的总功率。优化能源效率可以提高总体集群吞吐量：（1）允许更多应用程序并行运行，因为每个应用程序的功耗较低，而（2）由于其对能耗的影响仍在考虑应用程序运行时间。因此，需要新的资源管理方法，即使整体运行时间增加，也只关注最小化能耗以降低科学成本（以焦耳为单位）。</p>
<h2 id="学习能源效率"><a class="header-anchor" href="#学习能源效率">¶</a>学习能源效率</h2>
<p>识别能量有效的资源设置组合具有挑战性，因为系统没有通用的最佳设置 - 它取决于应用程序及其配置，甚至根据不同的输入而变化。即使在具有均匀节点和完全均匀的应用行为的并行系统中，由于制造变化，最佳设置也会发生显着变化。此外，许多应用程序在执行期间通过不同的阶段进行。例如，应用程序可能在计算和内存密集型处理之间进行转换，从而导致最节能的设置在运行时期间发生变化。因此，在启动应用程序时静态选择单个设置并不是最佳选择，而是需要采用动态方法。</p>
<p>本文探索了调整系统设置以最小化应用能耗的学习方法。具体来说，我们调整插槽（Socket）分配，使用HyperThreads和处理器DVFS。学习组件为这些资源的组合选择设置，使得在应用程序执行期间的任何时刻，系统都在其最节能的状态下运行。</p>
<p>本文的目标是让学习器在不需要任何应用程序级别更改的情况下进行最节能的设置。因此，我们使用现有的硬件性能计数器作为特征（Features）。然后，学习器确定相应的函数来将这些特征的一些子集映射到最节能系统设置。但是，现代计算节点中的系统设置具有非常复杂的交互关系，因此尽管存在这种复杂性，但使用能够生成准确映射的学习机制至关重要。</p>
<img src="/2019/08/02/论文阅读：Energy-dfficient-Application-Resource-Scheduling-using-Machine-Learning-Classifiers-ICPP18/Figure1.png" title="[20] [20]">
<p>我们只使用两个特征 - 性能计数器POWER_DRAM（内存使用量度量）和EXEC（CPU使用量度量）来简单地说明这种复杂性。图1a显示了关于标准化性能计数器值的训练数据（21个常见HPC基准）的行为。每个数据点是在我们的评估系统上以单一资源配置运行的训练应用程序的平均记录POWER_DRAM和EXEC行为。有88种独特的资源配置或可能的标签，它们考虑了Socket计数S的不同组合，是否使用了HyperThreads HT，以及DVFS频率（例如2.1 GHz）。属于特定应用的所有88个数据点被分配相同的标签 - 具有该应用的最佳能量效率的资源配置;即，应用程序的所有88个数据点具有相同的颜色。通过这种标记，一个好的学习器将识别次优行为并产生最节能的设置来代替使用。<strong><em>问题显然很复杂，并没有出现直观的模式将CPU和内存使用情况映射到最节能的系统设置中</em></strong>。</p>
<p>为了成功地将这些特征映射到准确的预测中，学习器必须能够处理这种复杂性，而不是所有机器学习机制都可以。考虑图1b表示使用线性内核的支持向量机（SVM）分类器的准确性。阴影区域表示SVM分类器预测的标签（系统设置），在训练集上的召回率仅为45.6%，这清楚地表明该分类器没有效果。相比之下，图1c展示了一个具有径向基函数（RBF）内核的SVM，它可以实现71.0％的召回率，但可能还有进一步改进的余地。</p>
<h2 id="系统设置的分类"><a class="header-anchor" href="#系统设置的分类">¶</a>系统设置的分类</h2>
<p>我们建议在运行时预测能量有效设置，而不是在产生结果之前估计所有可能系统设置的行为。与许多先前在HPC系统中管理功率/能量的工作一样，我们使用硬件性能计数器来测量应用和系统行为。</p>
<img src="/2019/08/02/论文阅读：Energy-dfficient-Application-Resource-Scheduling-using-Machine-Learning-Classifiers-ICPP18/Figure2.png" title="[20] [20]">
<p>图2展示了我们提出的方法。当应用程序在计算节点上运行时，硬件性能计数器会在后台定期轮询。对于我们的实验，我们使用PCM工具收集性能计数器数据。对数据进行缩放，然后使用主成分分析（PCA）进行处理，以确定哪些特征与能量效率相关。我们还使用特征选择来限制分类器使用的硬件计数器的数量，以减少运行时开销。该分类器预测要使用的最节能的设置，然后在系统上启动。该过程在下一个间隔重复进行。</p>
<h4 id="训练数据"><a class="header-anchor" href="#训练数据">¶</a>训练数据</h4>
<p>在使用之前必须训练一个分类器。为了收集训练数据，我们通过在所有可能的设置中运行基准应用程序并收集硬件性能计数器结果来描述基准应用程序在目标平台上的行为。换句话说，如果存在N个不同的可接受的设置，则每个应用程序执行N次，或者在每个设置中执行一次。对于M训练应用，训练集中有$N\times M$个特征向量。</p>
<p>训练数据的获取可能非常耗时，但只需要对每个平台进行一次，并且可以通过缩短应用程序执行时间来在合理的时间内完成。选择能够代表将在系统上使用的应用程序的基准测试程序可以提高分类器在运行时期间准确预测设置的可能性。此外，应将训练集中的基准测试程序以不同的模式运行,以涵盖硬件计数器的各种可能的用例。</p>
<p>应用能源效率（EE）定义为每单位能源（J）完成的工作量。一般而言，在我们的评估中，完整的应用程序执行是完成工作的度量。与许多使用性能计数器的先前工作一样，我们的分类器需要一种措施来量化运行时的应用程序进度。底层硬件性能计数器没有用于量化真实应用程序进度的指标（已完成工作），但先前的工作已成功使用系统执行的指令数量（INST）。一些先前的工作甚至试图仅测量那些被认为在测量应用程序进度中有用的指令，例如，忽略自旋锁或并行化/同步指令。使用INST是优化总应用能源效率的不完美解决方案，但正如实验评估所展示的那样，已经足够了。然后，该类别使用以下公式作为量化训练过程中的能量效率：<br>
$$<br>
EE=\frac{INST}{J}\tag{1}<br>
$$<br>
对于M个应用程序中的每一个程序，使用该应用程序的最节能设置来标记N个特征向量。因此，分类器学习有效和低效的行为，以便在观察到类似的运行时行为时产生一个有效的预测：<br>
$$<br>
FeatVec_{mn}\mapsto \underset{i\in N}{\arg max EE_i},    \forall m\in M, \forall n\in N\tag{2}<br>
$$<br>
对于应用程序执行，总指令计数不是固定的 : 计数通常随着应用程序执行时间而增加，例如，由于诸如PCM或内核任务的后台进程。因此，重要的是要注意使用公式2标记最节能的配置。在计算能量效率时使用指令计数有两个原因：首先，可以在执行期间的任何时候量化能量，使其成为运行时行为分析的有用指标。第二，更重要的是，公式1是当时发生的事件的函数。总能量需要知道在应用程序执行期间将发生的所有事件，这就引入了一种可能性，即分类器可能正在学习关于应用程序输入的一些知识，而不是硬件事件与能量消耗对应的方式。利用指令数量有助于避免这种陷阱。</p>
<h4 id="性能计数器"><a class="header-anchor" href="#性能计数器">¶</a>性能计数器</h4>
<p>性能计数器指标反映了不同层次粒度，即系统、插槽和核心。为简单起见，我们限制为系统范围的数据。表1列出了我们实验中所选择的性能计数器。</p>
<img src="/2019/08/02/论文阅读：Energy-dfficient-Application-Resource-Scheduling-using-Machine-Learning-Classifiers-ICPP18/Figure3.png" title="[20] [20]">
<p>性能计数器也会转换为采样速率（根据需要），这是为了在不缩放值的情况下改变采样间隔所必需的。因为我们使用PCM来收集性能计数器指标，所以我们读取的硬件计数器比我们处理的更多（表1）。实际上，现成的解决方案只能通过读取和处理所使用的性能计数器来减少开销。大多数先前的工作都积极地限制它们访问的硬件计数器，以减少采样开销并减少其模型中的计算。</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/HaoMengHIT">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://www.researchgate.net/profile/Meng_Hao3">Meng Hao&#39;s ResearchGate</a></span>
        <span>/</span>
        
        <span><a href="http://www.hit.edu.cn/">Harbin Institute of Technology</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> --!>

</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    <script>
        /**
         *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
         *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        if( '' || '')
        var disqus_config = function () {
            this.page.url = '';  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://airclouds-blog.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>



</html>
