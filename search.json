[{"title":"HPL参数优化","url":"/2019/07/31/HPL参数优化/","content":"### 1. 实验平台KNL配置\nIntel Xeon Phi Processor 7210 ( 16GB, 1.30 GHz, 64 core )\nProcessor name : Intel(R) Xeon Phi(TM) 7210\nPackages (sockets) : 1\nCores : 64\nProcessors (CPUs) : 256\nCores per package : 64\nThreads per core : 4\n\nRAM: 96GB\nMCDRAM: 16 GB\n\n理论峰值\n**n 1*64*1.3*32=2662.4 Gflops**\n\n### 2. HPL.dat文件中需要优化的参数\n\n```Bash\nHPLinpack benchmark input file\nInnovative Computing Laboratory, University of Tennessee\nHPL.out      output file name (if any)\n6            device out (6=stdout,7=stderr,file)\n1            # of problems sizes (N)\n50000 100000 150000 200000  Ns\n10            # of NBs\n1 2 4 8 16 32 64 128 256 512     NBs\n0            PMAP process mapping (0=Row-,1=Column-major)\n1            # of process grids (P x Q)\n1            Ps\n1            Qs\n16.0         threshold\n3            # of panel fact\n0 1 2        PFACTs (0=left, 1=Crout, 2=Right)\n2            # of recursive stopping criterium\n2 4          NBMINs (>= 1)\n1            # of panels in recursion\n2            NDIVs\n3            # of recursive panel fact.\n0 1 2        RFACTs (0=left, 1=Crout, 2=Right)\n1            # of broadcast\n0            BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)\n1            # of lookahead depth\n0            DEPTHs (>=0)\n2            SWAP (0=bin-exch,1=long,2=mix)\n64           swapping threshold\n0            L1 in (0=transposed,1=no-transposed) form\n0            U  in (0=transposed,1=no-transposed) form\n1            Equilibration (0=no,1=yes)\n8            memory alignment in double (> 0)\n```\n\n***需要优化的主要有N，NB，PxQ等***\n\n### 3. 根据内存情况，获取理论最优的N值\n\n根据KNL的MCDRAM为16G，N*N*8=16G，得到N约为46000\n从46000左右开始设置N值，进行测试。\n\n* log信息提取命令\n\n```Bash\nawk -F: '/WR/' knl003_hpl.o31829 > 30000_128_8_8.log\n```\n* 阶段性结果\n\n|N|NB|Ps|Qs|Result（Gflops）|\n| ------ | ------ | ------ |--------|-----|\n|30000|\t128|\t8|\t16|\t9.435e+02|\n|30000\t|128\t|16\t|16\t|9.086e+01|\n|30000\t|256\t|8\t|16\t|6.042e+02|\n|35000\t|128\t|8\t|16\t|1.034e+03|\n|35000\t|64\t|8\t|16\t|8.820e+02|\n|35000\t|128\t|14\t|14\t|6.002e+02|\n|35000\t|128\t|1\t|128\t|6.019e+02|\n|35000\t|128\t|10\t|16\t|7.427e+02|\n|35000\t|128\t|8\t|8\t|1.149e+03|\n|35000\t|128\t|8\t|10\t|8.718e+02|\n|39200\t|128\t|8\t|8\t|1.227e+03|\n|39200\t|175\t|8\t|8\t|1.208e+03|\n|41600\t|128\t|8\t|8\t|1.074e+03|\n|32768\t|128\t|8\t|8\t|1.111e+03|\n\n更改运行脚本\n\n```Bash\n#!/usr/bin/bash\n \n \n#PBS -N knl003_hpl\n#PBS -l nodes=1,walltime=01:00:00\n \ncd /home/asc0146/haomeng/code/hpl/bin/Linux_Intel64/test1/\nexport KMP_AFFINITY=scatter,verbose\nexport OMP_NUM_THREADS=4\nexport MKL_NUM_THREADS=4\nmpiexec -np 64 ./xhpl | tee HPL.out\n```\n进行实验\n\n|N\t|NB|\tPs|\tQs|\tResult（Gflops）|\n|-----|-----|-----|-----|-----|\n|35000|\t128|\t8\t|8\t|效果很差|\n\n* 参数选择指导\n\n参考[Developer Guide for Intel](https://software.intel.com/en-us/mkl-linux-developer-guide-configuring-parameters).\nThe most significant parameters in HPL.dat are P, Q, NB, and N. Specify them as follows:\n\n  * P and Q - the number of rows and columns in the process grid, respectively.\nP*Q must be the number of MPI processes that HPL is using.\nChoose P ≤ Q.\n\n  * NB - the block size of the data distribution.\nThe table below shows recommended values of NB for different Intel® processors:\n{% asset_img HPL.png \"KNL推荐配置\" %}\n\n  * N - the problem size:\nFor homogeneous runs, choose N divisible by NB*LCM(P,Q), where LCM is the least common multiple of the two numbers.\nFor heterogeneous runs, see Heterogeneous Support in the Inte；l Optimized MP LINPACK Benchmark for how to choose N.\n\n***NOTE***\n\nIncreasing N usually increases performance, but the size of N is bounded by memory. In general, you can compute the memory required to store the matrix (which does not count internal buffers) as 8*N*N/(P*Q) bytes, where N is the problem size and P and Q are the process grids in HPL.dat. A general rule of thumb is to choose a problem size that fills 80% of memory. When offloading to Intel Xeon Phi coprocessors, you may choose a problem size that fills 70% of memory, to leave room for additional buffers needed for offloading. Choose N and NB such that N > > NB.\n\n* 最新优化情况\n\n    * 优化结果\n\n|N|\tNB|\tPs|\tQs\t|Result（Gflops）|\n|----|----|----|-----|-----|\n|3920\t|128\t|8\t|16\t|9.435e+02|\n","tags":["并行"]},{"title":"HPC性能评测","url":"/2019/07/31/HPC性能评测/","content":"高性能计算集群的性能评测大致分为机器级、算法级和程序级的性能评测。\n\n* 机器级\n\n  机器级的性能评测主要包括CPU和存储器的某些基本性能指标、并行通讯开销以及机器的成本、价格和性/价比，有些是由厂商在销售时直接提供给用户的，是广大用户对并行计算机的第一印象，是引进和购买并行计算机时最主要的选择依据。\n\n\n\n* 算法级\n\n  算法级的性能评测主要包括加速、效率和可扩展性等，最初是为了评价并行算法的性能提出的，用在并行机性能评测主要是测并行系统的加速比和可扩展性。并行系统的加速比是指对于一个给定的应用，并行算法（或并行程序）的执行速度相对于串行算法的执行速度加快了多少倍。***可扩展性是在确定的应用背景下，并行系统性能随处理器数的增加而按比例提高的能力***。\n\n* 程序级\n\n  程序级的性能评测主要是使用一组基准测试来测试和评价并行系统的各种性能，包括基本测试、数学库测试和并行测试程序等。","tags":["并行"]},{"title":"并行程序性能分析软件（Extra-P和Score-P）安装过程","url":"/2019/07/31/并行程序性能分析软件（Extra-P和Score-P）安装过程/","content":"### Extra-P配置安装\n#### 安装位置\n* 实验室台式机虚拟机Ubuntukylin17.10\n#### 软件包依赖\n* QT4 或 QT5\n* Cube（>=4.3）\n* Python3\n* PyQT\n* MatPlotlib\n#### 安装过程\n* 安装Qt4或Qt5\n```\nsudo apt-get install qt4-default\nsudo apt-get install qt5-default\nsudo apt-get install qt4-dev-tools\nsudo apt-get install qt5-dev-tools\n```\n* 安装python3\n```\nsudo apt-get install python3\n```\n* 安装PyQt\n```\nsudo apt-get install pyqt4-dev-tools\nsudo apt-get install pyqt5-dev-tools\n```\n* 安装Cube \n下载Cube源码包cube-4.3.tar.gz\n```\n./configure\nmake\nmake all\n```\n使用QT5的话编译过程中会出现一些问题，选用Qt4能正常编译\n* 安装 MatPlotLib\n```\nsudo apt-get install python3-pip\nsudo python -m pip install -U pip\nsudo python -m pip install -U matplotlib\n```\n####编译Extra-P\n```\nmkdir build\ncd build\n../configure --with-cube=/opt/cube CPPFLAGS=\"-I/usr/include/python3.6m/\"\nmake\nmake install\n```\n### score-P配置安装\n```\nmkdir build\ncd build\n../configure \nmake\nmake install\n```","tags":["并行"]},{"title":"LLVM入门学习","url":"/2019/07/31/LLVM入门学习/","content":"### 1. LLVM各工具使用\n\n* Convert C to IR\n\n```\nclang -emit-llvm -S multiply.c -o multiply.ll\n```\n\nOr\n\n```\nclang -cc1 -emit-llvm testfile.c -o testfile.ll\n```\n\nOr\n\n```\nclang test.c -S -emit-llvm -o test.ll\n```\n\n\n\n* Convert IR to bc\n\n```\nllvm-as test.ll –o test.bc\n```\n\n\n\n* Converting LLVM bitcode to target machine assembly\n\n```\nllc test.bc –o test.s\n```\n\nOr \n\n```\nclang -S test.bc -o test.s\n```\n\n\n\n* Converting bc to IR\n\n```\nllvm-dis test.bc –o test.ll\n```\n\n\n\n* Transforming LLVM IR\n\n```\nopt –passname input.ll –o output.ll\n```\n\n\n\n* Linking llvm bc\n\n```\nllvm-link test1.bc test2.bc –o output.bc\n```\n\n\n\n* Executing llvm bc\n\n```\nlli output.bc\n```\n\n\n\n\n\n### 2. IRBuilder\n\n可以批量的插入指令\n\n* 在之前前面插入指令\n\n```\nInstruction *pi = ...;\nIRBuilder<> Builder(pi);\nCallInst* callOne = Builder.CreateCall(...);\nCallInst* callTwo = Builder.CreateCall(...);\nValue* result = Builder.CreateMul(callOne, callTwo);\n```\n\n* 在基本块后面插入指令\n\n```\nBasicBlock *pb = ...;\nIRBuilder<> Builder(pb);\nCallInst* callOne = Builder.CreateCall(...);\nCallInst* callTwo = Builder.CreateCall(...);\nValue* result = Builder.CreateMul(callOne, callTwo);\n```\n\n但IRBuilder方法对于常数的指令会被优化掉\n\n\n\n### 3. 遍历Funciton或BasicBlock\n\n除了使用\n\n```\nfor(auto F=M.begin(),E=M.end();F!=E;F++)\n```\n\n还可以使用\n\n```\nfor(Module::iterator F = M.begin(), E = M.end();F!=E;++F)\n```\n\n注意，这块要使用比要得到的高一级的迭代器，即如果得到Function，则使用Module::iterator;\n\n如果得到BasicBlock，则使用Function::iterator\n\n如果遍历Instruction，可使用BasicBlock::iterator,或\n\n如果遍历Instruction的参数，可使用Instrunction::op_iterator\n\n* Function 中有一个函数size()，可以得到该函数中基本块的数量\n\n\n\n### 4. LLvm编译DEBUG版本的命令\n\n```\nexport CC=gcc\n\nexport CXX=g++\n\n./configure --prefix=/home/haomeng/.local --sysconfdir=/etc --enable-shared --enable-libffi --enable-targets=all --disable-expensive-checks --disable-assertions --with-binutils-include=/usr/include --with-python=/usr/bin/python2 --disable-optimized --enable-debug-runtime\n\nmake REQUIRES_RTTI=1 -j 60\n\nmake install\n\n```\n\n### 5. Pass\n\n在LLVM框架中，Pass用于对LLVM IR进行优化，对IR进行处理与分析，生成优化后的代码。`opt`命令可以用来运行pass对IR进行处理。\n\n优化类型\n\n* opt 自带的优化\n\n步骤如下：\n\n```\nclang -S -O0 -emit-llvm example.c\n\nopt -O0 -S example.ll\n\nopt -O1 -S example.ll\n\nopt -O2 -S example.ll\n\nopt -O3 -S example.ll\n\n为了能够看到opt所调用的优化Pass，可以加入参数\n\n--debug-pass=Structure\n\n```\n\n参考：http://llvm.org/docs/CommandGuide/opt.html \n\n\n\n* 自己写Pass进行优化\n\n参考：http://llvm.org/docs/WritingAnLLVMPass.html\n\n\n\n* 在一个Pass里面调用别的Pass\n\ngetAnalysis函数\n\n\n\n* 通过Pass manager 对Pass进行管理\n\n\n\n* Analysis Pass 分析IR但不对IR进行修改，其结果可以在多个Pass中使用，直到IR改变\n\n没有更改IR内容就返回false\n\n### 6. LLVM的Use-Def获取\nAlternatively, it’s common to have an instance of the User Class and need to know what Values are used by it. The list of all Values used by a User is known as a use-def chain. Instances of class Instruction are common User s, so we might want to iterate over all of the values that a particular instruction uses (that is, the operands of the particular Instruction):\n```\nInstruction *pi = ...;\n \nfor (Use &U : pi->operands()) {\n  Value *v = U.get();\n  // ...\n}\n\n```\n\n### 7. LLVM中Def-Use获取\nFrequently, we might have an instance of the Value Class and we want to determine which Users use the Value. The list of all Users of a particular Value is called a def-use chain. \n\n* 函数的def-use\n\n```\nFunction *F = ...;\n \nfor (User *U : F->users()) {\n  if (Instruction *Inst = dyn_cast<Instruction>(U)) {\n    errs() << \"F is used in instruction:\\n\";\n    errs() << *Inst << \"\\n\";\n  }\n```\n或者\n```\nFunction *F = ...;\nfor (Value::use_iterator U = F->use_begin(), e = F->use_end(); U != e; ++U) {\n  if (Instruction *Inst = dyn_cast<Instruction>(&*(U->getUser()))) {\n    errs() << \"F is used in instruction:\\n\";\n    errs() << *Inst << \"\\n\";\n}\n```\n\n* 指令的Def-Use\n```\nInstruction *A = ...;\n \nfor (User *U : A->users()) {\n  if (Instruction *Inst = dyn_cast<Instruction>(U)) {\n    errs() << \"A is used in instruction:\\n\";\n    errs() << *Inst << \"\\n\";\n  }\n```\n或\n```\nInstruction *A = ...;\nfor (Value::use_iterator i = A->use_begin(), e = A->use_end(); i != e; ++i) {\n  if (Instruction *U = dyn_cast<Instruction>(&*(i->getUser()))) {\n  ...\n  }\n}\n```\n\n### 8. 遍历LLVM IR指令的操作数\n\n通过User中提供的op_iterator迭代器来遍历Instruction中的操作数\n```\nInstruction* V = ...\nfor (User::op_iterator op = V->op_begin(), e = V->op_end(); op != e; ++op){\n    if (Instruction *U = dyn_cast<Instruction>(op->get())) {\n...\n    }\n}\n```\n\n### 9. 获取Basic Block的前驱基本块\nLLVM已经提供了遍历基本块的所有前驱的函数\n```\nBasicBlock* B = ...\nfor (auto it = pred_begin(B), et = pred_end(B); it != et; ++it)\n{\n  BasicBlock* predecessor = *it;\n  ...\n}\n```","tags":["LLVM"]},{"title":"物理CPU和逻辑CPU的区别","url":"/2019/07/31/物理CPU和逻辑CPU的区别/","content":"A physical core is what it sounds like - an actual physical processor core in your CPU. Each physical core has its own circuitry and its own L1 (and usually L2) cache can read and execute instructions separately (for the most part) from the other physical cores on the chip.\n\nA logical core is more of a programming abstraction than an actual physical entity. A simple definition of a logical core is that it is a processing unit that is capable of executing its own thread in parallel with other logical cores. In fact you could say that a logical core is the same as a thread.\n\nYou can have multiple logical cores per physical core. However logical cores share resources with other logical cores operating on the same physical core, so having more logical cores will not necessarily get you the same performance increase as having more physical cores.\n\nIn the case of intel hyperthreading (HT), you have two logical cores per physical core, so a quad-(physical) core i7 processor will have eight logical cores. However the two logical cores within one physical core cannot truly operate in parallel with respect to each other. This is because HT works by having one logical core operate while the other logical core is waiting and has nothing to do (for example when it is waiting on a cache or memory fetch).\n\nWell then how can these logical cores be considered in parallel? Well most of the time they can be because during typical CPU operation you will almost never see continuous execution of a single thread on every clock cycle - there are always gaps when one logical core is waiting for something and the second logical core can kick in and do its job.","tags":["CPU"]},{"title":"PAPI安装问题","url":"/2019/07/31/PAPI安装问题/","content":"### 解决方法\nIt seems kernel didn't let me access to performance events because of security reasons. You have to set that.\n(由于安全原因，似乎内核不允许访问性能事件,必须对它进行设置)\n\n```shell\nsudo sh -c 'echo -1 >/proc/sys/kernel/perf_event_paranoid'\n```\n","tags":["RAPL","PAPI"]},{"title":"PAPI安装RAPL模块","url":"/2019/07/31/PAPI安装RAPL模块/","content":"### Configuring PAPI to support RAPL\nWhen configuring PAPI, you need to provide the --with-components=rapl option. Basically, you need to install PAPI like this:\n```\n$ tar xzvf papi-5.3.2.tar.gz\n$ cd papi-5.3.2/src\n$ ./configure --with-components=rapl &&make &&make install\n```\n### Checking the PAPI installation\nOnce PAPI is installed, make sure it is capable of reading RAPL information. For instance, you can run this [rapl-read](http://eztrace.gforge.inria.fr/tutorials/tutorial_rapl/rapl-read.tgz) program. You may need to modify the `Makefile` in order to specify the installation directory of PAPI. Once compiled, running the `rapl-read` program should result in the following output:\n\n```Bash\n$ ./rapl_plot\nFound rapl component at cid 2\nFound: rapl:::THERMAL_SPEC_CNT:PACKAGE0\nFound: rapl:::MINIMUM_POWER_CNT:PACKAGE0\nFound: rapl:::MAXIMUM_POWER_CNT:PACKAGE0\nFound: rapl:::MAXIMUM_TIME_WINDOW_CNT:PACKAGE0\nFound: rapl:::PACKAGE_ENERGY_CNT:PACKAGE0\nFound: rapl:::PP1_ENERGY_CNT:PACKAGE0\nFound: rapl:::DRAM_ENERGY_CNT:PACKAGE0\nFound: rapl:::PP0_ENERGY_CNT:PACKAGE0\nFound: rapl:::THERMAL_SPEC:PACKAGE0\nFound: rapl:::MINIMUM_POWER:PACKAGE0\nFound: rapl:::MAXIMUM_POWER:PACKAGE0\nFound: rapl:::MAXIMUM_TIME_WINDOW:PACKAGE0\nFound: rapl:::PACKAGE_ENERGY:PACKAGE0\nFound: rapl:::PP1_ENERGY:PACKAGE0\nFound: rapl:::DRAM_ENERGY:PACKAGE0\nFound: rapl:::PP0_ENERGY:PACKAGE0\n[...]\n4.7213 0.0 (* Average Power for rapl:::MAXIMUM_TIME_WINDOW:PACKAGE0 *)\n4.7213 3.0 (* Average Power for rapl:::PACKAGE_ENERGY:PACKAGE0 *)\n4.7213 0.2 (* Average Power for rapl:::PP1_ENERGY:PACKAGE0 *)\n4.7213 0.8 (* Average Power for rapl:::DRAM_ENERGY:PACKAGE0 *)\n4.7213 0.1 (* Average Power for rapl:::PP0_ENERGY:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::THERMAL_SPEC_CNT:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::MINIMUM_POWER_CNT:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::MAXIMUM_POWER_CNT:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::MAXIMUM_TIME_WINDOW_CNT:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::PACKAGE_ENERGY_CNT:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::PP1_ENERGY_CNT:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::DRAM_ENERGY_CNT:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::PP0_ENERGY_CNT:PACKAGE0 *)\n4.8218 46156882941.9 (* Average Power for rapl:::THERMAL_SPEC:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::MINIMUM_POWER:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::MAXIMUM_POWER:PACKAGE0 *)\n4.8218 0.0 (* Average Power for rapl:::MAXIMUM_TIME_WINDOW:PACKAGE0 *)\n4.8218 2.9 (* Average Power for rapl:::PACKAGE_ENERGY:PACKAGE0 *)\n4.8218 0.2 (* Average Power for rapl:::PP1_ENERGY:PACKAGE0 *)\n4.8218 0.8 (* Average Power for rapl:::DRAM_ENERGY:PACKAGE0 *)\n```\n### Can't open fd for cpu0: No such file or director\nHowever, You may have the following error:\n```\n$ ./rapl_plot\nFound rapl component at cid 2\nNo rapl events found: Can't open fd for cpu0: No such file or director\n```\nThis usually means that the msr kernel module that permits to read the energy counters is not loaded. This should be fixed by running modprobe:\n```\n$ sudo modprobe msr\n```\n### Can't open fd for cpu0: Operation not permitted\nAnother possible error is:\n```\n$  ./rapl_plot\nFound rapl component at cid 2\nNo rapl events found: Can't open fd for cpu0: Operation not permitted\n```\nIn that case, you may have to run the program as sudo:\n```\n$ sudo ./rapl_plot\n[...]\n```\n","tags":["RAPL"]},{"title":"RAPL介绍","url":"/2019/07/31/RAPL介绍/","content":"### 介绍RAPL的链接 \n\n1. RUNNING AVERAGE POWER LIMIT， https://01.org/zh/blogs/2014/running-average-power-limit-%E2%80%93-rapl?langredirect=1 \n\n2. Reading RAPL energy measurements from Linux, http://web.eece.maine.edu/~vweaver/projects/rapl/index.html \n \n3. Energy measurements in Linux，https://blog.chih.me/read-cpu-power-with-RAPL.html \n \n4. Intel® Power Governor, https://software.intel.com/en-us/articles/intel-power-governor\n","tags":["RAPL"]},{"title":"OpenMP编译成LLVM IR","url":"/2019/07/29/OpenMP编译成LLVM-IR/","content":"\nhttps://clang-omp.github.io/\n\n# 介绍\n\n目前clang/llvm编译器已经支持OpenMP，目前，OpenMP 3.1已经被clang/llvm 3.7完全支持。\n\n# 方法\n\n这是一个openmp程序\n\n```\n\n#include <omp.h>\n\n#include <stdio.h>\n\nint main() {\n\n#pragma omp parallel\n\nprintf(\"Hello from thread %d, nthreads %d\\n\", omp_get_thread_num(), omp_get_num_threads());\n\n}\n\n```\n\n将更改程序转化为相应的IR代码：\n\n```\n\nclang -fopenmp -emit-llvm -S test.c -o test.ll\n\n```\n\nIR代码如下：\n\n```\n\n; ModuleID = 'test.bc'\n\ntarget datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n\ntarget triple = \"x86_64-pc-linux-gnu\"\n\n%ident_t = type { i32, i32, i32, i32, i8* }\n\n@.str = private unnamed_addr constant [35 x i8] c\"Hello from thread %d, nthreads %d\\0A\\00\", align 1\n\n@.str.1 = private unnamed_addr constant [23 x i8] c\";unknown;unknown;0;0;;\\00\", align 1\n\n@0 = private unnamed_addr constant %ident_t { i32 0, i32 2, i32 0, i32 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1, i32 0, i32 0) }, align 8\n\n; Function Attrs: nounwind uwtable\n\ndefine i32 @main() #0 {\n\n  call void (%ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%ident_t* @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined. to void (i32*, i32*, ...)*))\n\n  ret i32 0\n\n}\n\n; Function Attrs: nounwind uwtable\n\ndefine internal void @.omp_outlined.(i32* noalias %.global_tid., i32* noalias %.bound_tid.) #0 {\n\n  %1 = alloca i32*, align 8\n\n  %2 = alloca i32*, align 8\n\n  store i32* %.global_tid., i32** %1, align 8\n\n  store i32* %.bound_tid., i32** %2, align 8\n\n  %3 = call i32 @omp_get_thread_num()\n\n  %4 = call i32 @omp_get_num_threads()\n\n  %5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str, i32 0, i32 0), i32 %3, i32 %4)\n\n  ret void\n\n}\n\ndeclare i32 @printf(i8*, ...) #1\n\ndeclare i32 @omp_get_thread_num() #1\n\ndeclare i32 @omp_get_num_threads() #1\n\ndeclare void @__kmpc_fork_call(%ident_t*, i32, void (i32*, i32*, ...)*, ...)\n\nattributes #0 = { nounwind uwtable \"disable-tail-calls\"=\"false\" \"less-precise-fpmad\"=\"false\" \"no-frame-pointer-elim\"=\"true\" \"no-frame-pointer-elim-non-leaf\" \"no-infs-fp-math\"=\"false\" \"no-nans-fp-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+fxsr,+mmx,+sse,+sse2\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\n\nattributes #1 = { \"disable-tail-calls\"=\"false\" \"less-precise-fpmad\"=\"false\" \"no-frame-pointer-elim\"=\"true\" \"no-frame-pointer-elim-non-leaf\" \"no-infs-fp-math\"=\"false\" \"no-nans-fp-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+fxsr,+mmx,+sse,+sse2\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\n\n!llvm.ident = !{!0}\n\n!0 = !{!\"clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)\"}\n\n```\n\n其中***mpc_fork_call***是OpenMP定义的运行时函数，用来生成线程池，每个线程将执行函数***omp_outlined***中的代码，该函数的代码就是对应并行域中的代码。\n\n\n{% asset_img example1.png [20] [10]%}\n\nOver!!!!\n","tags":["LLVM"]},{"title":"LLVM Pass工程建立过程","url":"/2019/07/29/LLVM-Pass工程建立过程/","content":"一般的Pass工程建立方法需要利用LLVM源码目录进行编译，本文介绍了另一种Pass工程建立和编译方法，与cmake相结合进行Pass编译。\n### 1. 环境安装\n* 安装LLVM和clang编译器\n\n```Bash\nsudo apt-get install clang\nsudo apt-get install clang++\nsudo apt-get install llvm\n```\n### 2. LLVM Pass工程目录\n该测试工程LLVM_Test主要包含两个文件夹cmake和src，其具体文件组织形式如下图所示。**需要注意的是，利用该工程编译Pass时只需要在src目录下添加相应的Pass源码即可，其他文件不需要修改**。\n{% asset_img example1.png %}\n\n\n具体内容如下：\n* cmake目录中的FindLLVM.cmake\n\n```Bash\n# - Find LLVM \n# This module can be used to find LLVM.\n# It requires that the llvm-config executable be available on the system path.\n# Once found, llvm-config is used for everything else.\n#\n# The following variables are set:\n#\n# LLVM_FOUND                 - Set to YES if LLVM is found.\n# LLVM_VERSION               - Set to the decimal version of the LLVM library.\n# LLVM_INCLUDE_DIRS          - A list of directories where the LLVM headers are located.\n# LLVM_LIBRARY_DIRS          - A list of directories where the LLVM libraries are located.\n# LLVM_LIBRARIES             - A list of libraries which should be linked\n# LLVM_DYNAMIC_LIBRARY       - A single dynamic llvm shared library\n# LLVM_DYNAMIC_LIBRARY_FOUND - Whether found the dynamic llvm shared library\n# LLVM_OPT                   - opt program in llvm\n# \n# Using Following macros to set static library:\n# llvm_map_components_to_libraries(OUTPUT_VARIABLE ${llvm components})\n# \n# tutorial:\n#   1.  select default LLVM version:\n#       cmake .. -DLLVM_RECOMMEND_VERSION=\"3.5\"\n#   2.  set include dir and link dir:\n#       include_directories(${LLVM_INCLUDE_DIRS})\n#       link_directories(${LLVM_LIBRARY_DIRS})\n#   3.a link static libraries:\n#       llvm_map_components_to_libraries(LLVM_IRREADER_LIRARY irreader)\n#       target_link_libraries(target\n#           ${LLVM_LIBRARIES}\n#           ${LLVM_IRREADER_LIRARY}\n#           )\n#   3.b link a dynamic library:\n#       target_link_libraries(target ${LLVM_DYNAMIC_LIBRARY}) \n#\n# 14-10-26: \n#    LLVM_RECOMMAND_VERSION --> LLVM_RECOMMEND_VERSION\n#    update tutorial\n# \n# version: 0.9.1\n#    add LLVM_FLAGS_NDEBUG means llvm build with NDEBUG\n#\n# version: 0.9\n#    remove LLVM_{C/CPP/CXX}_FLAGS which import -DNDEBUG\n#\n#\nif(NOT DEFINED LLVM_RECOMMEND_VERSION)\n   set(LLVM_RECOMMEND_VERSION \"\" CACHE STRING \"Switch the llvm version\")\n   set_property(CACHE LLVM_RECOMMEND_VERSION PROPERTY STRINGS \"\" \"3.4\" \"3.5\" \"3.9\")\nendif()\n\n\nif(NOT(DEFINED LLVM_ROOT) )\n\tif(NOT \"${LLVM_VERSION}\" EQUAL \"{LLVM_RECOMMEND_VERSION}\")\n\t\tunset(LLVM_CONFIG_EXE CACHE)\n\t\tunset(LLVM_DYNAMIC_LIBRARY CACHE)\n\tendif()\n\t# find llvm-config. perfers to the one with version suffix, Ex:llvm-config-3.2\n\tfind_program(LLVM_CONFIG_EXE NAMES \"llvm-config-${LLVM_RECOMMEND_VERSION}\" \"llvm-config\")\n   find_program(LLVM_OPT NAMES \"opt-${LLVM_RECOMMEND_VERSION}\" \"opt\")\n\n\tif(NOT LLVM_CONFIG_EXE)\n\t\tset(LLVM_FOUND False)\n      message(FATAL_ERROR \"Not Found LLVM (LLVM_RECOMMEND_VERSION=${LLVM_RECOMMEND_VERSION})\")\n\telse()\n\t\tset(LLVM_FOUND True)\n\tendif()\n\n\t# Get the directory of llvm by using llvm-config. also remove whitespaces.\n\texecute_process(COMMAND ${LLVM_CONFIG_EXE} --prefix OUTPUT_VARIABLE LLVM_ROOT\n\t\tOUTPUT_STRIP_TRAILING_WHITESPACE )\n\nendif()\n\nmacro(_llvm_config _var_name)\n    execute_process(COMMAND ${LLVM_CONFIG_EXE} ${ARGN} \n        OUTPUT_VARIABLE ${_var_name}\n        OUTPUT_STRIP_TRAILING_WHITESPACE\n        )\nendmacro()\n\nset(LLVM_INSTALL_PREFIX  ${LLVM_ROOT})\nadd_definitions(-D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS)\n\n_llvm_config(LLVM_VERSION --version)\nSTRING(REGEX REPLACE \"^([0-9]+)\\\\.[0-9]+(svn)?\\\\.?[0-9]*\" \"\\\\1\" LLVM_VERSION_MAJOR \"${LLVM_VERSION}\")\nSTRING(REGEX REPLACE \"^[0-9]+\\\\.([0-9]+)(svn)?\\\\.?[0-9]*\" \"\\\\1\" LLVM_VERSION_MINOR \"${LLVM_VERSION}\")\n_llvm_config(LLVM_LD_FLAGS --ldflags)\n_llvm_config(LLVM_LIBRARY_DIRS --libdir)\n_llvm_config(LLVM_INCLUDE_DIRS --includedir)\nstring(REGEX MATCH \"-l.*\" LLVM_LIBRARIES ${LLVM_LD_FLAGS})\n_llvm_config(LLVM_C_FLAGS --cflags)\nif(LLVM_C_FLAGS MATCHES \"-DNDEBUG\")\n   add_definitions(-DLLVM_FLAGS_NDEBUG)\nendif()\n\nfind_library(LLVM_DYNAMIC_LIBRARY \n\tNAMES \"LLVM\" \"LLVM-${LLVM_VERSION}\"\n   PATHS ${LLVM_LIBRARY_DIRS}\n   )\n\nif(NOT LLVM_DYNAMIC_LIBRARY)\n\tset(LLVM_DYNAMIC_LIBRARY_FOUND False)\nelse()\n\tset(LLVM_DYNAMIC_LIBRARY_FOUND True)\nendif()\n\nmacro(llvm_map_components_to_libraries _var_name)\n    _llvm_config(${_var_name} --libs \"${ARGN}\")\nendmacro()\n\nmessage(STATUS \"Found LLVM Version ${LLVM_VERSION} \")\n\n```\n* 主目录的CMakeLists.txt\n\n```\ncmake_minimum_required(VERSION 2.8)\nproject(Test)\n\nset(CMAKE_MODULE_PATH \n   ${CMAKE_MODULE_PATH}\n   ${CMAKE_SOURCE_DIR}/cmake\n   )\n\nif(NOT CMAKE_BUILD_TYPE)\n   set(CMAKE_BUILD_TYPE \"Release\")\nendif()\n\nfind_package(LLVM)\n\nadd_subdirectory(src)\n```\n* src目录中的CMakeLists.txt\n\n```\naux_source_directory(. DIR_SRCS)\ninclude_directories(\n\t${LLVM_PROF_INCLUDE_DIRS}\n\t${PROJECT_BINARY_DIR}\n\t${LLVM_INCLUDE_DIRS} \n   ../include\n\t)\nlink_directories(\n   ${LLVM_LIBRARY_DIRS} \n   )\n\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall --std=c++11 -fno-rtti\")\nset(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -DNO_DEBUG\")\nset(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG}\")\n\nadd_library(Test SHARED\n\t${DIR_SRCS}\n\t)\n\ntarget_link_libraries(Test\n\t${LLVM_DYNAMIC_LIBRARY}\n\t)\n\n```\n* src中的FunctionTest.cpp文件是LLVM Pass的一个示例，在该目录中可以编写相应的Pass\n\n```c++\n#include <llvm/Pass.h>\n#include <llvm/IR/Function.h>\n#include <llvm/IR/Module.h>\n#include <llvm/IR/Instructions.h>\n#include <llvm/IR/Constants.h>\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/IR/InstIterator.h>\n#include <llvm/IR/Operator.h>\n#include <llvm/Analysis/AliasAnalysis.h>\nusing namespace llvm;\nnamespace{\n    class MyTest:public FunctionPass\n    {\n        public:\n            static char ID;\n            MyTest():FunctionPass(ID){}\n            bool runOnFunction(Function &F) override;\n    };\n}\nchar MyTest::ID = 0;\nstatic RegisterPass<MyTest> X(\"MyTest\",\"My Test\",false,false);\nbool MyTest::runOnFunction(Function &F) {\n\n    Function *tmp = &F;\n    errs()<<tmp->getName()<<\"\\n\";\n    // 遍历函数中的所有基本块\n    for (Function::iterator bb = tmp->begin(); bb != tmp->end(); ++bb) {\n        // 遍历基本块中的每条指令\n        for (BasicBlock::iterator inst = bb->begin(); inst != bb->end(); ++inst) {\n            if (inst->isBinaryOp()) {\n\t\t\terrs()<<*inst<<\"\\n\";\n            }\n        }\n    }\n\n    return false;\n}\n\n```\n\n### 3. 编译过程\n\n```\ncd LLVM_Test/\nmkdir build\ncd build/\ncmake ..\nmake\n```\n编译出来的.so文件在LLVM_Test/build/src目录下。具体过程如下图所示：\n{% asset_img example2.png %}\n\n### 4. Pass调用\n利用该工程编译之后，我们就可以调用相应的Pass了，具体调用过程如下：\n\n```\nopt -load LLVM_Test/build/src/libTest.so -MyTest test.ll \n```\n","tags":["LLVM"]}]