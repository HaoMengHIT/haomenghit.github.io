[{"title":"LLVM Pass工程建立过程","url":"/2019/07/29/LLVM-Pass工程建立过程/","content":"一般的Pass工程建立方法需要利用LLVM源码目录进行编译，本文介绍了另一种Pass工程建立和编译方法，与cmake相结合进行Pass编译。\n### 1. 环境安装\n* 安装LLVM和clang编译器\n```\nsudo apt-get install clang\nsudo apt-get install clang++\nsudo apt-get install llvm\n```\n### 2. LLVM Pass工程目录\n该测试工程LLVM_Test主要包含两个文件夹cmake和src，其具体文件组织形式如下图所示。**需要注意的是，利用该工程编译Pass时只需要在src目录下添加相应的Pass源码即可，其他文件不需要修改**。\n![](https://upload-images.jianshu.io/upload_images/7858045-ed4ca3ed88a15bc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n具体内容如下：\n* cmake目录中的FindLLVM.cmake\n```\n# - Find LLVM \n# This module can be used to find LLVM.\n# It requires that the llvm-config executable be available on the system path.\n# Once found, llvm-config is used for everything else.\n#\n# The following variables are set:\n#\n# LLVM_FOUND                 - Set to YES if LLVM is found.\n# LLVM_VERSION               - Set to the decimal version of the LLVM library.\n# LLVM_INCLUDE_DIRS          - A list of directories where the LLVM headers are located.\n# LLVM_LIBRARY_DIRS          - A list of directories where the LLVM libraries are located.\n# LLVM_LIBRARIES             - A list of libraries which should be linked\n# LLVM_DYNAMIC_LIBRARY       - A single dynamic llvm shared library\n# LLVM_DYNAMIC_LIBRARY_FOUND - Whether found the dynamic llvm shared library\n# LLVM_OPT                   - opt program in llvm\n# \n# Using Following macros to set static library:\n# llvm_map_components_to_libraries(OUTPUT_VARIABLE ${llvm components})\n# \n# tutorial:\n#   1.  select default LLVM version:\n#       cmake .. -DLLVM_RECOMMEND_VERSION=\"3.5\"\n#   2.  set include dir and link dir:\n#       include_directories(${LLVM_INCLUDE_DIRS})\n#       link_directories(${LLVM_LIBRARY_DIRS})\n#   3.a link static libraries:\n#       llvm_map_components_to_libraries(LLVM_IRREADER_LIRARY irreader)\n#       target_link_libraries(target\n#           ${LLVM_LIBRARIES}\n#           ${LLVM_IRREADER_LIRARY}\n#           )\n#   3.b link a dynamic library:\n#       target_link_libraries(target ${LLVM_DYNAMIC_LIBRARY}) \n#\n# 14-10-26: \n#    LLVM_RECOMMAND_VERSION --> LLVM_RECOMMEND_VERSION\n#    update tutorial\n# \n# version: 0.9.1\n#    add LLVM_FLAGS_NDEBUG means llvm build with NDEBUG\n#\n# version: 0.9\n#    remove LLVM_{C/CPP/CXX}_FLAGS which import -DNDEBUG\n#\n#\nif(NOT DEFINED LLVM_RECOMMEND_VERSION)\n   set(LLVM_RECOMMEND_VERSION \"\" CACHE STRING \"Switch the llvm version\")\n   set_property(CACHE LLVM_RECOMMEND_VERSION PROPERTY STRINGS \"\" \"3.4\" \"3.5\" \"3.9\")\nendif()\n\n\nif(NOT(DEFINED LLVM_ROOT) )\n\tif(NOT \"${LLVM_VERSION}\" EQUAL \"{LLVM_RECOMMEND_VERSION}\")\n\t\tunset(LLVM_CONFIG_EXE CACHE)\n\t\tunset(LLVM_DYNAMIC_LIBRARY CACHE)\n\tendif()\n\t# find llvm-config. perfers to the one with version suffix, Ex:llvm-config-3.2\n\tfind_program(LLVM_CONFIG_EXE NAMES \"llvm-config-${LLVM_RECOMMEND_VERSION}\" \"llvm-config\")\n   find_program(LLVM_OPT NAMES \"opt-${LLVM_RECOMMEND_VERSION}\" \"opt\")\n\n\tif(NOT LLVM_CONFIG_EXE)\n\t\tset(LLVM_FOUND False)\n      message(FATAL_ERROR \"Not Found LLVM (LLVM_RECOMMEND_VERSION=${LLVM_RECOMMEND_VERSION})\")\n\telse()\n\t\tset(LLVM_FOUND True)\n\tendif()\n\n\t# Get the directory of llvm by using llvm-config. also remove whitespaces.\n\texecute_process(COMMAND ${LLVM_CONFIG_EXE} --prefix OUTPUT_VARIABLE LLVM_ROOT\n\t\tOUTPUT_STRIP_TRAILING_WHITESPACE )\n\nendif()\n\nmacro(_llvm_config _var_name)\n    execute_process(COMMAND ${LLVM_CONFIG_EXE} ${ARGN} \n        OUTPUT_VARIABLE ${_var_name}\n        OUTPUT_STRIP_TRAILING_WHITESPACE\n        )\nendmacro()\n\nset(LLVM_INSTALL_PREFIX  ${LLVM_ROOT})\nadd_definitions(-D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS)\n\n_llvm_config(LLVM_VERSION --version)\nSTRING(REGEX REPLACE \"^([0-9]+)\\\\.[0-9]+(svn)?\\\\.?[0-9]*\" \"\\\\1\" LLVM_VERSION_MAJOR \"${LLVM_VERSION}\")\nSTRING(REGEX REPLACE \"^[0-9]+\\\\.([0-9]+)(svn)?\\\\.?[0-9]*\" \"\\\\1\" LLVM_VERSION_MINOR \"${LLVM_VERSION}\")\n_llvm_config(LLVM_LD_FLAGS --ldflags)\n_llvm_config(LLVM_LIBRARY_DIRS --libdir)\n_llvm_config(LLVM_INCLUDE_DIRS --includedir)\nstring(REGEX MATCH \"-l.*\" LLVM_LIBRARIES ${LLVM_LD_FLAGS})\n_llvm_config(LLVM_C_FLAGS --cflags)\nif(LLVM_C_FLAGS MATCHES \"-DNDEBUG\")\n   add_definitions(-DLLVM_FLAGS_NDEBUG)\nendif()\n\nfind_library(LLVM_DYNAMIC_LIBRARY \n\tNAMES \"LLVM\" \"LLVM-${LLVM_VERSION}\"\n   PATHS ${LLVM_LIBRARY_DIRS}\n   )\n\nif(NOT LLVM_DYNAMIC_LIBRARY)\n\tset(LLVM_DYNAMIC_LIBRARY_FOUND False)\nelse()\n\tset(LLVM_DYNAMIC_LIBRARY_FOUND True)\nendif()\n\nmacro(llvm_map_components_to_libraries _var_name)\n    _llvm_config(${_var_name} --libs \"${ARGN}\")\nendmacro()\n\nmessage(STATUS \"Found LLVM Version ${LLVM_VERSION} \")\n\n```\n* 主目录的CMakeLists.txt\n```\ncmake_minimum_required(VERSION 2.8)\nproject(Test)\n\nset(CMAKE_MODULE_PATH \n   ${CMAKE_MODULE_PATH}\n   ${CMAKE_SOURCE_DIR}/cmake\n   )\n\nif(NOT CMAKE_BUILD_TYPE)\n   set(CMAKE_BUILD_TYPE \"Release\")\nendif()\n\nfind_package(LLVM)\n\nadd_subdirectory(src)\n```\n* src目录中的CMakeLists.txt\n```\naux_source_directory(. DIR_SRCS)\ninclude_directories(\n\t${LLVM_PROF_INCLUDE_DIRS}\n\t${PROJECT_BINARY_DIR}\n\t${LLVM_INCLUDE_DIRS} \n   ../include\n\t)\nlink_directories(\n   ${LLVM_LIBRARY_DIRS} \n   )\n\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall --std=c++11 -fno-rtti\")\nset(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -DNO_DEBUG\")\nset(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG}\")\n\nadd_library(Test SHARED\n\t${DIR_SRCS}\n\t)\n\ntarget_link_libraries(Test\n\t${LLVM_DYNAMIC_LIBRARY}\n\t)\n\n```\n* src中的FunctionTest.cpp文件是LLVM Pass的一个示例，在该目录中可以编写相应的Pass\n```\n#include <llvm/Pass.h>\n#include <llvm/IR/Function.h>\n#include <llvm/IR/Module.h>\n#include <llvm/IR/Instructions.h>\n#include <llvm/IR/Constants.h>\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/IR/InstIterator.h>\n#include <llvm/IR/Operator.h>\n#include <llvm/Analysis/AliasAnalysis.h>\nusing namespace llvm;\nnamespace{\n    class MyTest:public FunctionPass\n    {\n        public:\n            static char ID;\n            MyTest():FunctionPass(ID){}\n            bool runOnFunction(Function &F) override;\n    };\n}\nchar MyTest::ID = 0;\nstatic RegisterPass<MyTest> X(\"MyTest\",\"My Test\",false,false);\nbool MyTest::runOnFunction(Function &F) {\n\n    Function *tmp = &F;\n    errs()<<tmp->getName()<<\"\\n\";\n    // 遍历函数中的所有基本块\n    for (Function::iterator bb = tmp->begin(); bb != tmp->end(); ++bb) {\n        // 遍历基本块中的每条指令\n        for (BasicBlock::iterator inst = bb->begin(); inst != bb->end(); ++inst) {\n            if (inst->isBinaryOp()) {\n\t\t\terrs()<<*inst<<\"\\n\";\n            }\n        }\n    }\n\n    return false;\n}\n\n```\n\n### 3. 编译过程\n```\ncd LLVM_Test/\nmkdir build\ncd build/\ncmake ..\nmake\n```\n编译出来的.so文件在LLVM_Test/build/src目录下。具体过程如下图所示：\n![](https://upload-images.jianshu.io/upload_images/7858045-fd7bf728b20f901a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 4. Pass调用\n利用该工程编译之后，我们就可以调用相应的Pass了，具体调用过程如下：\n```\nopt -load LLVM_Test/build/src/libTest.so -MyTest test.ll \n```\n","tags":["LLVM"]}]